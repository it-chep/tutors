// Code generated by xo. DO NOT EDIT.
// Package xo contains the types for schema 'public'.
package xo

import (
	"database/sql"
	"fmt"
	"reflect"
	"strings"
)

// Permission represents a row from 'public.permissions'.
type Permission struct {
	ID          int64          `db:"id" json:"id"`                   // id bigint
	Name        string         `db:"name" json:"name"`               // name character varying(50)
	URL         string         `db:"url" json:"url"`                 // url text
	Description sql.NullString `db:"description" json:"description"` // description text
}

// zeroPermission zero value of dto
var zeroPermission = Permission{}

// Constants that should be used when building where statements
const (
	Alias_Permission             = "p"
	Table_Permission_With_Alias  = "permissions AS p"
	Table_Permission             = "permissions"
	Field_Permission_ID          = "id"
	Field_Permission_Name        = "name"
	Field_Permission_URL         = "url"
	Field_Permission_Description = "description"
)

func (t Permission) SelectColumnsWithCoalesce() []string {
	return []string{
		fmt.Sprintf("COALESCE(p.id, %v) as id", zeroPermission.ID),
		fmt.Sprintf("COALESCE(p.name, '%v') as name", zeroPermission.Name),
		fmt.Sprintf("COALESCE(p.url, '%v') as url", zeroPermission.URL),
		"p.description",
	}
}

func (t Permission) SelectColumns() []string {
	return []string{
		"p.id",
		"p.name",
		"p.url",
		"p.description",
	}
}

func (t Permission) Columns(without ...string) []string {
	var str = "id, name, url, description"
	for _, exc := range without {
		str = strings.Replace(str+", ", exc+", ", "", 1)
	}
	return strings.Split(strings.TrimRight(str, ", "), ", ")
}

func (t Permission) WithTable(col string) string {
	return fmt.Sprintf("p.%s", col)
}

func (t Permission) IsEmpty() bool {
	return reflect.DeepEqual(t, zeroPermission)
}

func (t Permission) Join(rightColumnTable string, leftColumnTable string) string {
	return fmt.Sprintf("permissions AS p ON p.%s = %s", rightColumnTable, leftColumnTable)
}

func (t *Permission) ToMap() map[string]interface{} {
	return map[string]interface{}{
		"id":          t.ID,
		"name":        t.Name,
		"url":         t.URL,
		"description": t.Description,
	}
}

func (t *Permission) Values(colNames ...string) (vals []interface{}) {
	m := t.ToMap()

	for _, v := range colNames {
		vals = append(vals, m[v])
	}

	return vals
}
