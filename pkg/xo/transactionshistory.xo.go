// Code generated by xo. DO NOT EDIT.
// Package xo contains the types for schema 'public'.
package xo

import (
	"database/sql"
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/lib/pq"
)

// TransactionsHistory represents a row from 'public.transactions_history'.
type TransactionsHistory struct {
	ID          uuid.UUID      `db:"id" json:"id"`                     // id uuid
	OrderID     sql.NullString `db:"order_id" json:"order_id"`         // order_id text
	CreatedAt   time.Time      `db:"created_at" json:"created_at"`     // created_at timestamp without time zone
	ConfirmedAt pq.NullTime    `db:"confirmed_at" json:"confirmed_at"` // confirmed_at timestamp without time zone
	Amount      pgtype.Numeric `db:"amount" json:"amount"`             // amount numeric
	StudentID   int64          `db:"student_id" json:"student_id"`     // student_id bigint
}

// zeroTransactionsHistory zero value of dto
var zeroTransactionsHistory = TransactionsHistory{}

// Constants that should be used when building where statements
const (
	Alias_TransactionsHistory             = "th"
	Table_TransactionsHistory_With_Alias  = "transactions_history AS th"
	Table_TransactionsHistory             = "transactions_history"
	Field_TransactionsHistory_ID          = "id"
	Field_TransactionsHistory_OrderID     = "order_id"
	Field_TransactionsHistory_CreatedAt   = "created_at"
	Field_TransactionsHistory_ConfirmedAt = "confirmed_at"
	Field_TransactionsHistory_Amount      = "amount"
	Field_TransactionsHistory_StudentID   = "student_id"
)

func (t TransactionsHistory) SelectColumnsWithCoalesce() []string {
	return []string{
		fmt.Sprintf("COALESCE(th.id, %v) as id", zeroTransactionsHistory.ID),
		"th.order_id",
		fmt.Sprintf("COALESCE(th.created_at, '%v') as created_at", zeroTransactionsHistory.CreatedAt.Format(time.RFC3339)),
		"th.confirmed_at",
		fmt.Sprintf("COALESCE(th.amount, %v) as amount", zeroTransactionsHistory.Amount),
		fmt.Sprintf("COALESCE(th.student_id, %v) as student_id", zeroTransactionsHistory.StudentID),
	}
}

func (t TransactionsHistory) SelectColumns() []string {
	return []string{
		"th.id",
		"th.order_id",
		"th.created_at",
		"th.confirmed_at",
		"th.amount",
		"th.student_id",
	}
}

func (t TransactionsHistory) Columns(without ...string) []string {
	var str = "id, order_id, created_at, confirmed_at, amount, student_id"
	for _, exc := range without {
		str = strings.Replace(str+", ", exc+", ", "", 1)
	}
	return strings.Split(strings.TrimRight(str, ", "), ", ")
}

func (t TransactionsHistory) WithTable(col string) string {
	return fmt.Sprintf("th.%s", col)
}

func (t TransactionsHistory) IsEmpty() bool {
	return reflect.DeepEqual(t, zeroTransactionsHistory)
}

func (t TransactionsHistory) Join(rightColumnTable string, leftColumnTable string) string {
	return fmt.Sprintf("transactions_history AS th ON th.%s = %s", rightColumnTable, leftColumnTable)
}

func (t *TransactionsHistory) ToMap() map[string]interface{} {
	return map[string]interface{}{
		"id":           t.ID,
		"order_id":     t.OrderID,
		"created_at":   t.CreatedAt,
		"confirmed_at": t.ConfirmedAt,
		"amount":       t.Amount,
		"student_id":   t.StudentID,
	}
}

func (t *TransactionsHistory) Values(colNames ...string) (vals []interface{}) {
	m := t.ToMap()

	for _, v := range colNames {
		vals = append(vals, m[v])
	}

	return vals
}
