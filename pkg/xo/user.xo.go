// Code generated by xo. DO NOT EDIT.
// Package xo contains the types for schema 'public'.
package xo

import (
	"database/sql"
	"fmt"
	"reflect"
	"strings"

	"github.com/lib/pq"
)

// User represents a row from 'public.users'.
type User struct {
	ID         int64          `db:"id" json:"id"`                   // id bigint
	Email      string         `db:"email" json:"email"`             // email character varying(255)
	Password   sql.NullString `db:"password" json:"password"`       // password character varying(255)
	FullName   sql.NullString `db:"full_name" json:"full_name"`     // full_name character varying(100)
	IsActive   sql.NullBool   `db:"is_active" json:"is_active"`     // is_active boolean
	ActivateAt pq.NullTime    `db:"activate_at" json:"activate_at"` // activate_at timestamp without time zone
	CreatedAt  pq.NullTime    `db:"created_at" json:"created_at"`   // created_at timestamp without time zone
	RoleID     sql.NullInt64  `db:"role_id" json:"role_id"`         // role_id bigint
	TutorID    sql.NullInt64  `db:"tutor_id" json:"tutor_id"`       // tutor_id bigint
	Tg         string         `db:"tg" json:"tg"`                   // tg text
	Phone      string         `db:"phone" json:"phone"`             // phone text
}

// zeroUser zero value of dto
var zeroUser = User{}

// Constants that should be used when building where statements
const (
	Alias_User            = "u"
	Table_User_With_Alias = "users AS u"
	Table_User            = "users"
	Field_User_ID         = "id"
	Field_User_Email      = "email"
	Field_User_Password   = "password"
	Field_User_FullName   = "full_name"
	Field_User_IsActive   = "is_active"
	Field_User_ActivateAt = "activate_at"
	Field_User_CreatedAt  = "created_at"
	Field_User_RoleID     = "role_id"
	Field_User_TutorID    = "tutor_id"
	Field_User_Tg         = "tg"
	Field_User_Phone      = "phone"
)

func (t User) SelectColumnsWithCoalesce() []string {
	return []string{
		fmt.Sprintf("COALESCE(u.id, %v) as id", zeroUser.ID),
		fmt.Sprintf("COALESCE(u.email, '%v') as email", zeroUser.Email),
		"u.password",
		"u.full_name",
		fmt.Sprintf("COALESCE(u.is_active, %v) as is_active", zeroUser.IsActive),
		"u.activate_at",
		"u.created_at",
		"u.role_id",
		"u.tutor_id",
		fmt.Sprintf("COALESCE(u.tg, '%v') as tg", zeroUser.Tg),
		fmt.Sprintf("COALESCE(u.phone, '%v') as phone", zeroUser.Phone),
	}
}

func (t User) SelectColumns() []string {
	return []string{
		"u.id",
		"u.email",
		"u.password",
		"u.full_name",
		"u.is_active",
		"u.activate_at",
		"u.created_at",
		"u.role_id",
		"u.tutor_id",
		"u.tg",
		"u.phone",
	}
}

func (t User) Columns(without ...string) []string {
	var str = "id, email, password, full_name, is_active, activate_at, created_at, role_id, tutor_id, tg, phone"
	for _, exc := range without {
		str = strings.Replace(str+", ", exc+", ", "", 1)
	}
	return strings.Split(strings.TrimRight(str, ", "), ", ")
}

func (t User) WithTable(col string) string {
	return fmt.Sprintf("u.%s", col)
}

func (t User) IsEmpty() bool {
	return reflect.DeepEqual(t, zeroUser)
}

func (t User) Join(rightColumnTable string, leftColumnTable string) string {
	return fmt.Sprintf("users AS u ON u.%s = %s", rightColumnTable, leftColumnTable)
}

func (t *User) ToMap() map[string]interface{} {
	return map[string]interface{}{
		"id":          t.ID,
		"email":       t.Email,
		"password":    t.Password,
		"full_name":   t.FullName,
		"is_active":   t.IsActive,
		"activate_at": t.ActivateAt,
		"created_at":  t.CreatedAt,
		"role_id":     t.RoleID,
		"tutor_id":    t.TutorID,
		"tg":          t.Tg,
		"phone":       t.Phone,
	}
}

func (t *User) Values(colNames ...string) (vals []interface{}) {
	m := t.ToMap()

	for _, v := range colNames {
		vals = append(vals, m[v])
	}

	return vals
}
