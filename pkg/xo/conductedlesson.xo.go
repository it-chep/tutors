// Code generated by xo. DO NOT EDIT.
// Package xo contains the types for schema 'public'.
package xo

import (
	"database/sql"
	"fmt"
	"reflect"
	"strings"

	"github.com/lib/pq"
)

// ConductedLesson represents a row from 'public.conducted_lessons'.
type ConductedLesson struct {
	ID                int64        `db:"id" json:"id"`                                   // id bigint
	CreatedAt         pq.NullTime  `db:"created_at" json:"created_at"`                   // created_at timestamp without time zone
	TutorID           int64        `db:"tutor_id" json:"tutor_id"`                       // tutor_id bigint
	StudentID         int64        `db:"student_id" json:"student_id"`                   // student_id bigint
	DurationInMinutes int64        `db:"duration_in_minutes" json:"duration_in_minutes"` // duration_in_minutes bigint
	IsTrial           sql.NullBool `db:"is_trial" json:"is_trial"`                       // is_trial boolean
}

// zeroConductedLesson zero value of dto
var zeroConductedLesson = ConductedLesson{}

// Constants that should be used when building where statements
const (
	Alias_ConductedLesson                   = "cl"
	Table_ConductedLesson_With_Alias        = "conducted_lessons AS cl"
	Table_ConductedLesson                   = "conducted_lessons"
	Field_ConductedLesson_ID                = "id"
	Field_ConductedLesson_CreatedAt         = "created_at"
	Field_ConductedLesson_TutorID           = "tutor_id"
	Field_ConductedLesson_StudentID         = "student_id"
	Field_ConductedLesson_DurationInMinutes = "duration_in_minutes"
	Field_ConductedLesson_IsTrial           = "is_trial"
)

func (t ConductedLesson) SelectColumnsWithCoalesce() []string {
	return []string{
		fmt.Sprintf("COALESCE(cl.id, %v) as id", zeroConductedLesson.ID),
		"cl.created_at",
		fmt.Sprintf("COALESCE(cl.tutor_id, %v) as tutor_id", zeroConductedLesson.TutorID),
		fmt.Sprintf("COALESCE(cl.student_id, %v) as student_id", zeroConductedLesson.StudentID),
		fmt.Sprintf("COALESCE(cl.duration_in_minutes, %v) as duration_in_minutes", zeroConductedLesson.DurationInMinutes),
		fmt.Sprintf("COALESCE(cl.is_trial, %v) as is_trial", zeroConductedLesson.IsTrial),
	}
}

func (t ConductedLesson) SelectColumns() []string {
	return []string{
		"cl.id",
		"cl.created_at",
		"cl.tutor_id",
		"cl.student_id",
		"cl.duration_in_minutes",
		"cl.is_trial",
	}
}

func (t ConductedLesson) Columns(without ...string) []string {
	var str = "id, created_at, tutor_id, student_id, duration_in_minutes, is_trial"
	for _, exc := range without {
		str = strings.Replace(str+", ", exc+", ", "", 1)
	}
	return strings.Split(strings.TrimRight(str, ", "), ", ")
}

func (t ConductedLesson) WithTable(col string) string {
	return fmt.Sprintf("cl.%s", col)
}

func (t ConductedLesson) IsEmpty() bool {
	return reflect.DeepEqual(t, zeroConductedLesson)
}

func (t ConductedLesson) Join(rightColumnTable string, leftColumnTable string) string {
	return fmt.Sprintf("conducted_lessons AS cl ON cl.%s = %s", rightColumnTable, leftColumnTable)
}

func (t *ConductedLesson) ToMap() map[string]interface{} {
	return map[string]interface{}{
		"id":                  t.ID,
		"created_at":          t.CreatedAt,
		"tutor_id":            t.TutorID,
		"student_id":          t.StudentID,
		"duration_in_minutes": t.DurationInMinutes,
		"is_trial":            t.IsTrial,
	}
}

func (t *ConductedLesson) Values(colNames ...string) (vals []interface{}) {
	m := t.ToMap()

	for _, v := range colNames {
		vals = append(vals, m[v])
	}

	return vals
}
