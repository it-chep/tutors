// Code generated by xo. DO NOT EDIT.
// Package xo contains the types for schema 'public'.
package xo

import (
	"database/sql"
	"fmt"
	"reflect"
	"strings"
)

// PaymentCred represents a row from 'public.payment_cred'.
type PaymentCred struct {
	AdminID     int64          `db:"admin_id" json:"admin_id"`         // admin_id bigint
	UserPay     string         `db:"user_pay" json:"user_pay"`         // user_pay text
	PasswordPay string         `db:"password_pay" json:"password_pay"` // password_pay text
	Bank        sql.NullString `db:"bank" json:"bank"`                 // bank text
	BaseURL     sql.NullString `db:"base_url" json:"base_url"`         // base_url text
	Cred        []byte         `db:"cred" json:"cred"`                 // cred jsonb
}

// zeroPaymentCred zero value of dto
var zeroPaymentCred = PaymentCred{}

// Constants that should be used when building where statements
const (
	Alias_PaymentCred             = "pc"
	Table_PaymentCred_With_Alias  = "payment_cred AS pc"
	Table_PaymentCred             = "payment_cred"
	Field_PaymentCred_AdminID     = "admin_id"
	Field_PaymentCred_UserPay     = "user_pay"
	Field_PaymentCred_PasswordPay = "password_pay"
	Field_PaymentCred_Bank        = "bank"
	Field_PaymentCred_BaseURL     = "base_url"
	Field_PaymentCred_Cred        = "cred"
)

func (t PaymentCred) SelectColumnsWithCoalesce() []string {
	return []string{
		fmt.Sprintf("COALESCE(pc.admin_id, %v) as admin_id", zeroPaymentCred.AdminID),
		fmt.Sprintf("COALESCE(pc.user_pay, '%v') as user_pay", zeroPaymentCred.UserPay),
		fmt.Sprintf("COALESCE(pc.password_pay, '%v') as password_pay", zeroPaymentCred.PasswordPay),
		"pc.bank",
		"pc.base_url",
		"pc.cred",
	}
}

func (t PaymentCred) SelectColumns() []string {
	return []string{
		"pc.admin_id",
		"pc.user_pay",
		"pc.password_pay",
		"pc.bank",
		"pc.base_url",
		"pc.cred",
	}
}

func (t PaymentCred) Columns(without ...string) []string {
	var str = "admin_id, user_pay, password_pay, bank, base_url, cred"
	for _, exc := range without {
		str = strings.Replace(str+", ", exc+", ", "", 1)
	}
	return strings.Split(strings.TrimRight(str, ", "), ", ")
}

func (t PaymentCred) WithTable(col string) string {
	return fmt.Sprintf("pc.%s", col)
}

func (t PaymentCred) IsEmpty() bool {
	return reflect.DeepEqual(t, zeroPaymentCred)
}

func (t PaymentCred) Join(rightColumnTable string, leftColumnTable string) string {
	return fmt.Sprintf("payment_cred AS pc ON pc.%s = %s", rightColumnTable, leftColumnTable)
}

func (t *PaymentCred) ToMap() map[string]interface{} {
	return map[string]interface{}{
		"admin_id":     t.AdminID,
		"user_pay":     t.UserPay,
		"password_pay": t.PasswordPay,
		"bank":         t.Bank,
		"base_url":     t.BaseURL,
		"cred":         t.Cred,
	}
}

func (t *PaymentCred) Values(colNames ...string) (vals []interface{}) {
	m := t.ToMap()

	for _, v := range colNames {
		vals = append(vals, m[v])
	}

	return vals
}
