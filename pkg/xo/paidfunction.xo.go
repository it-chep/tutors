// Code generated by xo. DO NOT EDIT.
// Package xo contains the types for schema 'public'.
package xo

import (
	"fmt"
	"reflect"
	"strings"
)

// PaidFunction represents a row from 'public.paid_functions'.
type PaidFunction struct {
	AdminID   int64  `db:"admin_id" json:"admin_id"`   // admin_id bigint
	Functions []byte `db:"functions" json:"functions"` // functions jsonb
}

// zeroPaidFunction zero value of dto
var zeroPaidFunction = PaidFunction{}

// Constants that should be used when building where statements
const (
	Alias_PaidFunction            = "pf"
	Table_PaidFunction_With_Alias = "paid_functions AS pf"
	Table_PaidFunction            = "paid_functions"
	Field_PaidFunction_AdminID    = "admin_id"
	Field_PaidFunction_Functions  = "functions"
)

func (t PaidFunction) SelectColumnsWithCoalesce() []string {
	return []string{
		fmt.Sprintf("COALESCE(pf.admin_id, %v) as admin_id", zeroPaidFunction.AdminID),
		"pf.functions",
	}
}

func (t PaidFunction) SelectColumns() []string {
	return []string{
		"pf.admin_id",
		"pf.functions",
	}
}

func (t PaidFunction) Columns(without ...string) []string {
	var str = "admin_id, functions"
	for _, exc := range without {
		str = strings.Replace(str+", ", exc+", ", "", 1)
	}
	return strings.Split(strings.TrimRight(str, ", "), ", ")
}

func (t PaidFunction) WithTable(col string) string {
	return fmt.Sprintf("pf.%s", col)
}

func (t PaidFunction) IsEmpty() bool {
	return reflect.DeepEqual(t, zeroPaidFunction)
}

func (t PaidFunction) Join(rightColumnTable string, leftColumnTable string) string {
	return fmt.Sprintf("paid_functions AS pf ON pf.%s = %s", rightColumnTable, leftColumnTable)
}

func (t *PaidFunction) ToMap() map[string]interface{} {
	return map[string]interface{}{
		"admin_id":  t.AdminID,
		"functions": t.Functions,
	}
}

func (t *PaidFunction) Values(colNames ...string) (vals []interface{}) {
	m := t.ToMap()

	for _, v := range colNames {
		vals = append(vals, m[v])
	}

	return vals
}
